#####################################################################
# 	Sensorless Homing
#####################################################################
[stepper_x]
endstop_pin: tmc2209_stepper_x:virtual_endstop
homing_retract_dist: 0
homing_speed: 20

[stepper_y]
endstop_pin: tmc2209_stepper_y:virtual_endstop
homing_retract_dist: 0
homing_speed: 20

[tmc2209 stepper_x]
diag_pin: ^PG6
driver_SGTHRS: 60 # min: 50, max: 81, tested 60 20x

[tmc2209 stepper_y]
diag_pin: ^PG9
driver_SGTHRS: 60 # min: 50, max: 76, tested 60 20x

[gcode_macro _WAIT_FOR_ENDSTOP_CLEARED]
gcode:
    # Break out of the sandbox just a little
    {% set lookup_object = printer.__dict__['printer'].lookup_object %}
    {% set toolhead = lookup_object('toolhead') %}
    {% set query_endstops = lookup_object('query_endstops') %}

    {% set endstop = params.ENDSTOP %}
    {% set wait = params.WAIT | default(0.05) | float %} # Wait 50ms each loop
    {% set max = params.MAX | default(2) | float %}
    {% set debug = 'DEBUG' in params or (printer.save_variables and printer.save_variables.variables.debug) %}
    {% set start = params.START | default(toolhead.get_last_move_time()) | float %}

    {% for mcu_endstop, name in query_endstops.endstops if name == endstop %}
        {% set printtime = toolhead.get_last_move_time() %}
        {% set triggered = mcu_endstop.query_endstop(printtime) %}

        {% if debug %}
            {action_respond_info("%s - %r, waiting at most %f more for clear" % (
                endstop, 
                'TRIGGERED' if triggered else 'OPEN',
                max
            ))}
        {% endif %}

        {% if triggered %}
            G4 P{wait}
            {% if max < (printtime - start) %}
                _WAIT_FOR_ENDSTOP_CLEARED ENDSTOP={endstop} WAIT={wait} MAX={max} START={start} {% if debug %}DEBUG=1{% endif %}
            {% endif %}
        {% endif %}
    {% else %}
        {action_raise_error("endstop %s not found (debug: %r)" % (driver,))}
    {% endfor %}

[homing_override]
axes: xyz
gcode:
    # RESPOND MSG='homing start'
    {% set SENSORLESS_HOME_CURRENT = 0.7 %}

    {% set XY_RETRACT = 20 %}
    {% set XY_TRAVEL_FEEDRATE = 200 * 60 %}
    
    {% set Z_TRAVEL_FEEDRATE = 50 * 60 %}
    {% set Z_HOME_POSITION = (95, 300) %}
    {% set Z_HOP = 10 %}

    # These variables should probably be left alone, unless you have a need to changed them
    {% set X_HOME_START_POSITION = printer.toolhead.axis_maximum[0] - XY_RETRACT %}
    {% set Y_HOME_START_POSITION = printer.toolhead.axis_maximum[1] - XY_RETRACT %}
    
    # And here there be dragons
    # First was save which axes are homed at the start
    {% set is_X_homed = 'x' in printer.toolhead.homed_axes %}
    {% set is_Y_homed = 'y' in printer.toolhead.homed_axes %}
    {% set is_Z_homed = 'z' in printer.toolhead.homed_axes %}

    # Now we figure out which axes are requested to be homed. 
    #  This could be much faster done if we had rawparams, but that requires klipper
    #  code changes.
    {% set _home_all = (
        'XYZ' in params
        or (
            'X' not in params
            and 'Y' not in params
            and 'Z' not in params
            and 'XY' not in params
            and 'XZ' not in params
            and 'YZ' not in params
        )
    ) %}
    {% set _X_in_params = 'X' in params or 'XY' in params or 'XZ' in params %}
    {% set _Y_in_params = 'Y' in params or 'XY' in params or 'YZ' in params %}
    {% set _Z_in_params = 'Z' in params or 'XZ' in params or 'YZ' in params %}
    
    # Ok, this mess generates the "safety" table of which axis are correct to home
    #   When X or Y is not homed, and the other of the axis will be homed as well.
    #   However, if X or Y *is* homed, the other axis may be independantly homed
    {% set home_X = _home_all or _X_in_params or (not is_X_homed and _Y_in_params) %}
    {% set home_Y = _home_all or _Y_in_params or (not is_Y_homed and _X_in_params) %}
    # Z must be homed if coming from an un-homed state, or it will be left at a 
    #   random position Z_HOP above the start position and klipper will think it is
    #   homed
    {% set home_Z = _home_all or _Z_in_params or not is_Z_homed %}

    {% if 'DEBUG' in params or (printer.save_variables and printer.save_variables.variables.debug) %}
        # Some helpful debugging
        {action_respond_info("homing %s%s%s (already homed: %r, current position: X%r Y%r Z%r, debug: %r)" % (
            "X" if home_X else "",
            "Y" if home_Y else "",
            "Z" if home_Z else "",
            printer.toolhead.homed_axes or 'none',
            printer.toolhead.position[0],
            printer.toolhead.position[1],
            printer.toolhead.position[2],
            (params,),
        ))}
    {% endif %}

    # Poor/smart mans homing_override.set_position_#
    # Axis are only "updated" when they're not already homed, which allows to home 
    #   single axis here. We set XY to the axis maximum positions, which is in preparation
    #   for their safety retract before homing to max.
    # Z is set to 0, which sets up for the required minimum safety hop to avoid eating PEI
    #   when homing from a power loss at Z0, or in the middle of a failed print
    {% if 'xyz' not in printer.toolhead.homed_axes %}
        # RESPOND MSG="SET_KINEMATIC_POSITION {%- if not is_X_homed %} X={printer.toolhead.axis_maximum[0]} {% endif %} {%- if not is_Y_homed %} Y={printer.toolhead.axis_maximum[1]} {% endif %} {%- if not is_Z_homed %} Z=0 {% endif %}"
        SET_KINEMATIC_POSITION
            {%- if not is_X_homed %} X={printer.toolhead.axis_maximum[0]} {% endif %}
            {%- if not is_Y_homed %} Y={printer.toolhead.axis_maximum[1]} {% endif %}
            {%- if not is_Z_homed %} Z=0 {% endif %}
    {% endif %}

    # Perform the safety hop, this will do nothing if Z was already homed and is above
    #   the hop height
    {% if printer.toolhead.position[2] < Z_HOP %}
        # RESPOND MSG="homing z_hop start"
        SAVE_GCODE_STATE NAME=homing_lift_z
            G90
            G1 Z{Z_HOP} F{Z_TRAVEL_FEEDRATE}
        RESTORE_GCODE_STATE NAME=homing_lift_z
        # RESPOND MSG="homing z_hop end"
    {% endif %}

    {% if home_X or home_Y %}
        # RESPOND MSG="homing retract xy"
        # For CoreXY, we need to ensure we are not at maximum or a perpendicular
        #   axis maximum, or sensorless homing may errantly trigger
        SAVE_GCODE_STATE NAME=homing_retract_xy
            G90
            G0 X{X_HOME_START_POSITION} Y{Y_HOME_START_POSITION} F{XY_TRAVEL_FEEDRATE}
        RESTORE_GCODE_STATE NAME=homing_retract_xy

        # RESPOND MSG="homing set low currents"
        SET_TMC_CURRENT STEPPER=stepper_x CURRENT={SENSORLESS_HOME_CURRENT}
        SET_TMC_CURRENT STEPPER=stepper_y CURRENT={SENSORLESS_HOME_CURRENT}

        {% if home_X %}
            # RESPOND MSG="homing x"
            # Wait until stallguard is cleared
            _WAIT_FOR_ENDSTOP_CLEARED ENDSTOP=x
            G28 X

            # RESPOND MSG="homing x retract"
            SAVE_GCODE_STATE NAME=homing_retract
                G90
                G0 X{X_HOME_START_POSITION} F{XY_TRAVEL_FEEDRATE}
            RESTORE_GCODE_STATE NAME=homing_retract
        {% endif %}

        {% if home_Y %}
            # RESPOND MSG="homing y"
            _WAIT_FOR_ENDSTOP_CLEARED ENDSTOP=y
            G28 Y

            # RESPOND MSG="homing y retract"
            SAVE_GCODE_STATE NAME=homing_retract
                G90
                G0 Y{Y_HOME_START_POSITION} F{XY_TRAVEL_FEEDRATE}
            RESTORE_GCODE_STATE NAME=homing_retract
        {% endif %}

        # RESPOND MSG="restore ab currents"
        SET_TMC_CURRENT STEPPER=stepper_x CURRENT={printer.configfile.settings['tmc2209 stepper_x'].run_current}
        SET_TMC_CURRENT STEPPER=stepper_y CURRENT={printer.configfile.settings['tmc2209 stepper_y'].run_current}
    {% endif %}

    {% if home_Z %}
        # RESPOND MSG="homing z"
        SAVE_GCODE_STATE NAME=homing_override_z
            G90
            # RESPOND MSG="z  move to endstop"
            G1 X{Z_HOME_POSITION[0]} Y{Z_HOME_POSITION[1]} F{XY_TRAVEL_FEEDRATE}
            # RESPOND MSG="z  probe nozzle"
            G28 Z
            # RESPOND MSG="z  retract"
            G1 Z10 F{Z_TRAVEL_FEEDRATE}
        RESTORE_GCODE_STATE NAME=homing_override_z
        # RESPOND MSG="homing z complete"
    {% endif %}